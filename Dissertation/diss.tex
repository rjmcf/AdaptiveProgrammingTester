% Template for a Computer Science Tripos Part II project dissertation
\documentclass[12pt,a4paper,twoside,openright]{report}
\usepackage[pdfborder={0 0 0}]{hyperref}    % turns references into hyperlinks
\usepackage[margin=25mm]{geometry}  % adjusts page layout
\usepackage{graphicx}  % allows inclusion of PDF, PNG and JPG images
\usepackage{verbatim}
\usepackage{docmute}   % only needed to allow inclusion of proposal.tex
\usepackage{listings} % Great for code
\usepackage{color} % Uses color to remind me of things to do.
\lstset{language=Java, showstringspaces=false, basicstyle=\ttfamily\footnotesize, tabsize = 4} % listings settings

\graphicspath{ {figs/} }

\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\rightline{\LARGE \textbf{Robin McFarland}}

\vspace*{60mm}
\begin{center}
\Huge
\textbf{Giving Programming Exercises Adaptive Difficulty} \\[5mm]
Computer Science Tripos -- Part II \\[5mm]
Homerton College \\[5mm]
2017
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Robin McFarland                       \\
College:            & \bf Homerton College                     \\
Project Title:      & \bf Giving Programming Exercises Adaptive Difficulty \\
Examination:        & \bf Computer Science Tripos -- Part II, July 2017  \\
Word Count:         & \bf TBC  \\
Project Originator: & Mr Michael B.~Gale                   \\
Supervisor:         & Mr Michael B.~Gale                    \\ 
\end{tabular}
}

\section*{Original Aims of the Project}


\section*{Work Completed}

\section*{Special Difficulties}
 
\newpage
\section*{Declaration}

I, Robin McFarland of Homerton College, being a candidate for Part II of the Computer
Science Tripos, hereby declare
that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\leftline{Signed [signature]}

\medskip
\leftline{Date [date]}

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}

\pagestyle{headings}

\chapter{Introduction}

\textcolor{red}{MiniJava is a language I have developed.}

\chapter{Preparation}

\textcolor{red}{
\begin{itemize}
\item{First attempt using Strings}
\item{Why I had to make my own language}
\item{Research into other projects etc, like Arjen and the PhD}
\end{itemize}
}

Since part of my aim was to demonstrate a possible method for teaching Java, I wanted the language I was using to be as close to Java as possible. However, re-implementing all of Java would have been too much unnecessary complexity, so I designed MiniJava with reference to only a small subset of the Java 8 grammar \cite[p.714]{Java8}. Since nodes in the AST represent constructs in the source code, replacing a node in the AST with a notional ``blank'' node would be representative of making parts of the source code blank. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Implementation chapter
\chapter{Implementation}

\textcolor{red}{("it feels a lot like you are explaining the code with the expectation that the reader is looking at the code and reads your description alongside it, when you should really be explaining how it works and what the intuition is (note: explaining how something works is not the same as explaining the code)")}

\textcolor{red}{("You should be approaching the write-up from the perspective of "how do I explain the problems and solutions to someone who has never seen anything about this project before", don't go through the code, pick parts, and describe those.")}

In this chapter I detail the work completed. I begin by describing how I implemented MiniJava, (a small imperative programming language based on Java), as well as a parser for MiniJava's grammar. I then describe the algorithm that allows the addition and removal of ``blanks'' within a MiniJava program. I then describe how a programming exercise is conceptualised in the abstract sense, and give an example of an implementation of a specific question. Finally, I describe the two peripherals I developed to interact with the language; the \texttt{ExerciseSetter} and the Graphical User Interface (GUI).

\section{MiniJava's Abstract Syntax Tree}

In this section I describe the implementation of the MiniJava language.

Each class in my implementation represents a different production rule in the abstract syntax for MiniJava, found in Appendix \ref{App:Parser} in the form of a parser specification. It is important to differentiate between MiniJava expressions and MiniJava statement as they must be used in different places. For example, in the production rule \texttt{WHILE~parExpression~statement} representing a \texttt{while} loop, \texttt{parExpression} may be substituted with any MiniJava expression (surrounded by parentheses), while \texttt{statement} may be substituted with any MiniJava statement. The reverse is not allowed however, meaning that \texttt{statement} may not be replaced by a MiniJava expression and vice versa. This distinction is made by the interfaces \texttt{Expression} and \texttt{BlockStatement} (which all MiniJava expressions and statements implement respectively), and the abstract classes \texttt{ExpressionBase} and \texttt{StatementBase} (which all MiniJava expressions and statements extend respectively). Both interfaces and abstract class are used here because of the need to include blanks in the grammar. As explained in section \ref{Sec:Blanks}, there are two classes representing blanks: \texttt{FillableBlankExpr} and \texttt{FillableBlankStmnt}. The first of these should be a MiniJava expression and the second should be a MiniJava statement, meaning they should extend \texttt{ExpressionBase} and \texttt{StatementBase} respectively, but both of them must also extend the abstract class \texttt{FillableBlank}. Since classes in Java cannot extend more than one base class, the only alternative is for them to implement the \texttt{Expression} and \texttt{BlockStatement} interfaces. However, removing \texttt{ExpressionBase} and \texttt{StatementBase} would result in too much repeated code across the whole grammar, so the grammar requires both the interfaces and the abstract classes. The enumeration \texttt{SingleWordStmnt} (discussed on page \pageref{Para:SingleWordStmnt}) must also be a MiniJava statement, and since enumerations cannot extend abstract classes, it must also implement \texttt{BlockStatement}, further cementing the need for both the interfaces and the abstract classes.

As important as the distinction between expressions and statements is, there do exist some expressions that can be used in statements. For an example, the MiniJava code \texttt{i~=~5;} is a statement because it ends in a semicolon,~``\texttt{;}'', but this statement consists entirely of the expression \texttt{i~=~5} (this allows for the chaining of assignments found in the Java grammar \cite[p.589]{Java8}). This sort of expression within a statement construct is not possible with all expressions, for example the code \texttt{i~+~4;} would not be valid MiniJava. To make the distinction between expressions which may be used in statements like this and those which may not, I made the interface \texttt{StatementExpression}. This interface is only implemented by those expressions which can be used in a statement this way.

A feature of MiniJava is the concept of operator precedence, which is used to disambiguate an otherwise ambiguous grammar of expressions. Without the concept of operator precedence, the code \texttt{1~+~2~*~3} is ambiguous, as it can be read as either \texttt{(1~+~2)~*~3} which equates to 9, or as \texttt{1~+~(2~*~3)} which equates to 7. Since a single arithmetic expression cannot have more than one value, a decision must be made as to which of these interpretations is declared valid. The decision taken aligns with the standard arithmetic order of operations, such that the answer of 7 is the correct answer in this case. This example demonstrates that the multiplication operator, ``\texttt{*}'', has a higher precedence than the addition operator, ``\texttt{+}''. All the possible operators in MiniJava are found within this precedence hierarchy, and I needed some way to encode this. The method I chose for this is the natural choice, since it is suggested by the Java grammar itself \cite[p.723]{Java8}. The production rule for \texttt{AdditiveExpression} is as follows:
\samepage{
\begin{lstlisting}
AdditiveExpression:
	MultiplicativeExpression								(1)
	AdditiveExpression + MultiplicativeExpression			(2)
	AdditiveExpression - MultiplicativeExpression			(3)
\end{lstlisting}}
and the production rule for \texttt{MultiplicativeExpression} is as follows:
\samepage{
\begin{lstlisting}
MultiplicativeExpression:
	UnaryExpression
	MultiplicativeExpression * UnaryExpression
	MultiplicativeExpression / UnaryExpression 
	// Note that the modulus operator, %, was removed from MiniJava
\end{lstlisting}}
This means that for any expression $A$\texttt{ + }$B$, the expression $A$ must only contain subexpressions that use operators with precedence at least as high as \texttt{+} and \texttt{-}, and $B$ must only contain subexpressions that use operators with precedence higher than \texttt{+} and \texttt{-}. For any expression $A$\texttt{ * }$B$, neither $A$ nor $B$ can contain subexpressions that use operators with precedence lower than \texttt{*} and \texttt{/}. This in turn indicates that an expression such as \texttt{1~+~2~*~3~+~4} can only be interpreted as \texttt{1~+~(2~*~3)~+~4}, and an expression such as \texttt{1~*~2~+~3~*~4} can only be interpreted as \texttt{(1~*~2)~+~(3~*~4)}. I wanted an operator precedence for MiniJava that is hardcoded within the grammar of MiniJava itself, just as the operator precedence of Java is hardcoded within the grammar of Java. The production rules for Java shown above suggest a natural implementation of the class that represents addition expressions:
\samepage{
\begin{lstlisting}
class AddExpr {
	private boolean isPlus;
	private AddExpr leftSide;
	private MultExpr rightSide;
	...
}
\end{lstlisting}}
Here, the \texttt{isPlus} field records whether the expression is an addition or a subtraction, \texttt{leftSide} and \texttt{rightSide} store the left and right operands of the expression, and \texttt{MultExpr} is the class representing multiplication expressions. What has been implemented so far encapsulates parts (2) and (3) of the \texttt{AdditiveExpression} production rule above, but not part (1). This part is encapsulated by making the class \texttt{MultExpr} extend the class \texttt{AddExpr}, such that an instance of \texttt{MultExpr} may always be used in place of an instance of \texttt{AddExpr}. Note that since multiplication operators are higher in the operator precedence hierarchy, their representations are lower in the object hierarchy. This then is the solution to the operator precedence problem: to enforce an operator precedence hierarchy, first enforce an inverse object hierarchy in their representative classes, and then choose the type of each expression's operands to match the relevant terminal symbols in the relevant production rule.\footnote{Note that if you were to look at my implementation of \texttt{AddExpr}, \texttt{leftSide} and \texttt{rightSide} would both be \texttt{int}s, not \texttt{AddExpr} and \texttt{MultExpr} instances. The reason behind this is explained in section \ref{Sec:Blanks}.}

\begin{figure}
\centering
\includegraphics{TopLevelUML}
\caption{The UML diagram showing the top of the object hierarchy for \texttt{MiniJASTNode}s.}
\label{Fig:UML}
\end{figure}

Figure \ref{Fig:UML} shows the top of the object hierarchy for the implementation of MiniJava. It demonstrates the distinction between MiniJava expressions and statements by way of the \texttt{Expression} and \texttt{BlockStatement} interfaces, the extra classification of expressions that can be used as statements given by \texttt{StatementExpression}, and shows the beginnings of the operator precedence hierarchy hardcoded into the expressions. The \texttt{MiniJASTNode} class is discussed in section \ref{Sec:Blanks}.

Note also that as a side-effect of this implementation, the ambiguous code \texttt{1~+~2~+~3} also only has one possible interpretation, namely \texttt{(1~+~2)~+~3}. This follows the established rules of operator associativity, which are now also hardcoded into the grammar.

In MiniJava, every expression has a type which consists of a primitive type and may or may not be an array type. There are four possible primitive types: \texttt{boolean}, \texttt{char}, \texttt{int}, and \texttt{double}. The primitive types are represented in the grammar by the enumeration, \texttt{PrimType}. The type of an expression then is represented by the class \texttt{Type}, an instance of which stores the appropriate PrimType value and a flag determining whether or not it is an array type.These \texttt{Type}s are use by the interpreter to determine whether or not variables can contain certain values, and whether operators are being supplied with the appropriate operands.

The majority of statements in MiniJava are composed of statements or expressions, but there are some that consist of only a single word, or even no words at all. To have an entire class representing each of these trivial statements seems wasteful, so the enumeration \label{Para:SingleWordStmnt}\texttt{SingleWordStmnt} represents four such statements: the break statement (\texttt{break;}), the continue statement (\texttt{continue;}), the return statement (\texttt{return;}), and the empty statement (\texttt{;}). Although there are no functions in the MiniJava grammar, the return statement can be used to immediately halt evaluation.

As we have seen previously, \texttt{AddExpr} defines the boolean field \texttt{isPlus}, to determine whether this instance represents an addition or a subtraction. There are some expressions where the number of possible operators that can be used in that expression is greater than two, in which case a boolean field will not be enough to disambiguate. \texttt{RelationExpr} and \texttt{AssignExpr} are the two expressions for which this is the case, since there are four relation operators and five assignment operators. These possible operators are represented by the two enumerations \texttt{RelationOp} and \texttt{AssignOp}. Thus \texttt{RelationExpr} stores a value of \texttt{RelationOp}, and \texttt{AssignExpr} stores a value of \texttt{AssignOp}.

There are two possible MiniJava expressions that can be assigned to, i.e. they can appear on the left hand side of an assignment expression. These two, identifiers and array accesses, are represented by the classes \texttt{Id} and \texttt{ArrayAccess}. To signify that they can both be assigned to, both classes implement the \texttt{AssignLHS} interface, an interface used for only this purpose. Similarly, there are two possible MiniJava expressions that can be assigned to an array type variable. These are array creation expressions (for example \texttt{new int[4]}) and array initialisation expressions (for example \texttt{\{1, 2, 3, 4\}}), which are represented by the classes \texttt{arrayCreation} and \texttt{ArrayInit} respectively. To signify that both can be assigned to arrays, they both extend the abstract class, \texttt{ArrayAssignRightSide}. To justify why \texttt{AssignLHS} is an interface and \texttt{ArrayAssignRightSide} is an abstract class, we consider the difference between the expressions that can appear as subexpressions of other expressions, and those that cannot. Identifiers and array accesses may appear as a subexpression of some other expression. Because of this, the index operator used in array accesses must appear within the operator precedence hierarchy described previously, and so too must identifiers. If identifiers were not present in the operator precedence hierarchy, then they could never be substituted for the terminal symbols in the production rules seen previously, ruling out valid expressions like \texttt{i~+~j}. If identifiers and array accesses must appear in the operator precedence hierarchy, and high up in it too, then that means their representative classes must extend some class representing an operator lower down in the hierarchy. Thus \texttt{AssignLHS} must be an interface and not an abstract class, as \texttt{Id} and \texttt{ArrayAccess} already subclass some other class (namely \texttt{UnaryExpr}). Array creation and initialisation expressions however can never appear as a subexpression of some expression (since only single-dimensional arrays are allowed, expressions such as \texttt{\{\{1\},\{2,3,4\}\}} are not valid). This means that they do not appear in the operator precedence hierarchy, and thus their representations do not need to extend any base class. Thus \texttt{ArrayAssignRightSide} can usefully be an abstract class, reducing the amount of repeated code in these two classes.

MiniJava uses local variable declarations (for example, \texttt{int i = 4, ar[];}) in the same way that Java does: to define and initialise new variables. Local variable declarations can be thought of as being made up of a primitive type and a list of so called ``variable declarators'', which are identifiers that may or may not be followed by square brackets to show the new variable is an array, and which may or may not be followed by an equals sign, ``\texttt{=}'', and a value with which to initialise the new variable. My implementation represents local variable declarations using the class \texttt{LocalVarDec}, which consists of a \texttt{PrimType} and a list of \texttt{VarDeclarator} instances. The \texttt{VarDeclarator} class stores a String containing the name of the variable, flags to determine whether the variable is an array type and whether an initialiser expression is given, and the initialiser expression itself if there is one.

In this section I have described the implementation of my MiniJava language.

\section{Interpreting the language}

In this section I explain how MiniJava programs are interpreted.

To correctly interpret MiniJava, several requirements must be met by the interpreter:
\begin{enumerate}
\item{The scope of variables must be handled, such that when a variable is used its current value can be accessed, and the same variable can't be declared twice in one scope.}
\item{Expressions must be able to propagate their values upwards, so that surrounding expressions and statements can use them.}
\item{Flow control must be handled, such the break and continue statements can be used in loops.}
\end{enumerate}

The scope of variables is handled by the interpreter with instances of the \texttt{Context} class. Part of its definition is shown below:
\begin{lstlisting}
public class Context {
	public Stack<HashMap<String, Type>> namesToTypes;
	public Stack<HashMap<String, Object>> namesToValues;
	...
}
\end{lstlisting}
The \texttt{namesToTypes} field is a stack of maps from names (as \texttt{String} values) to instances of my \texttt{Type} class. Every variable that is declared in this scope will have an entry in the map on top of this stack, recording the type of that variable. The \texttt{namesToValues} field is a stack of maps from names to instances of \texttt{Object}. If a variable has an entry in the map on top of this stack, then the variable has the value stored in the map with it in this scope. It is possible for a variable to have an entry in the map on top of the \texttt{namesToTypes} stack, but not in the map on top of the \texttt{namesToValues} stack: this indicates that the variable has been declared but not initialised in this scope.

During execution, the interpreter must keep track when variables will go out of scope. This is handled by the \texttt{stepIn} and \texttt{stepOut} methods in \texttt{StatementBase}. The \texttt{stepIn} method is called whenever execution enters a new, deeper, scope. This method copies every key value pair in the maps on top of their respective stacks into new maps, and pushes these new maps onto the stack. Thus every entry in one of the stacks represents a different scope: as you move down the stack, you move outward through the nested scope. The \texttt{stepOut} method is called whenever execution leaves the current scope. At this point, all the variables that do not exist in the new scope should be forgotten, and every variable that does exist in this new scope should have their value updated to the value it was in the old scope. The \texttt{stepOut} method first pops the top off both stacks, storing the top of the \texttt{namesToValues} stack in the local variable \texttt{oldMap}. Then, for every key in \texttt{oldMap}, if this key also appears in the new top of the \texttt{namesToTypes} stack, the corresponding value in \texttt{oldMap} is used to update the top of the \texttt{namesToValues} stack. In this way, variables can be updated in deeper levels of scope, and retain their new values when execution moves up the nested scope.

Consider the expression \texttt{(2*3)+4}. In MiniJava, this expression might be represented by a \texttt{AddExpr} storing a literal with the value \texttt{4} as the right operand, and an \texttt{MultExpr} as the left operand. This \texttt{MultExr} would store literals with values \texttt{2} and \texttt{3} as the left and right operands. During the evaluation of an expression, the most deeply nested parts of the expression must be evaluated first, so that their values can be used further up in the nested expression. There is no point trying to evaluate the \texttt{AddExpr} before we know the value of \texttt{(2*3)}. Thus, the \texttt{MultExpr} needs a way to communicate to the \texttt{AddExpr} that it has a value of \texttt{6}, so that the \texttt{AddExpr} can be evaluated to \texttt{10}. Likewise, whatever context the \texttt{AddExpr} is in needs to be told it has the value \texttt{10}. The way this is done in MiniJava is using implementations of the \texttt{ReturnValues} abstract class. This class represents the notion that some value is being returned by an expression, but allows any type of value to be returned, no matter what primitive type the value takes, and whether it's an array or not. To return a value of a particular primitive type, the appropriate one of these four implementations must be used: \texttt{ReturnValuesBool}, \texttt{ReturnValuesChar}, \texttt{ReturnValuesInt}, or \texttt{ReturnValuesDouble}. Each of these has a public \texttt{value} field of the appropriate type. If an array value is being returned by an expression, then a further implementation of \texttt{ReturnValues} must be used, the generic class \texttt{ReturnValuesArray<T>}. This class makes use of Java Generics as it stores an internal \texttt{ArrayList<T>} of values.

Consider the statement \texttt{i = i + 5;}. This would be represented in MiniJava as an \texttt{AssignExpr} storing an identifier with name \texttt{i} as the left hand side of the assignment, and an \texttt{AddExpr} as the right hand side. This \texttt{AddExpr} stores the same identifier as the left hand side of the 

Consider now the statement \texttt{a[i++] = i;}. This would be represented in MiniJava as an \texttt{AssignExpr} storing an identifier with name \texttt{i} as the right hand side of the assignment and an \texttt{ArrayAccess} as the left hand side. This \texttt{ArrayAccess} stores an identifier with name \texttt{a}, and a \texttt{UnaryPostIncExpr} as the index. This \texttt{UnaryPostIncExpr} stores an identifier with name \texttt{i}. In the evaluation of this expression, the expression is evaluated from left to right, with the most deeply nested parts evaluated first. Let us assume that the identifier \texttt{i} has a value of 0 currently. First of all, the representation of the code \texttt{i++} is evaluated. A \texttt{ReturnValuesInt} storing the value 0 is returned, and the value of \texttt{i} is updated to 1.



\texttt{a[i++]} is first evaluated as an array access to ensure that \texttt{a} and \texttt{i} are both initialised, and also get the value of \texttt{a[i++]}. Thus the \texttt{ReturnValues} object returned is a \texttt{ReturnValuesInt} that stores the value of \texttt{a[i++]}. The \texttt{i} on the right hand side is then evaluated, and the assignment is ready to take place. \textcolor{red}{(Fluffy, don't use "recognises")}The system recognises that there is an assignment to an array, and attempts to update the value in the \texttt{namesToValues} map, but the system has no way to know what index to store the value at. The \texttt{ReturnValues} object doesn't store it, the \texttt{ArrayAccess} object itself stores it as an \texttt{Expression} which must be evaluated to get a value, which would not only be wrong, but also change the value of \texttt{i} again. Thus there is no way to update an array without having a special version of \texttt{ReturnValues} used for array accesses that also store the index it was meant to be stored at.

\samepage{
\begin{lstlisting}
public interface Expression extends MiniJASTNode {
	ReturnValues evaluate(Context c) throws MiniJASTException;
	...
}

public interface BlockStatement extends MiniJASTNode {
	FlowControl execute(Context c) throws MiniJASTException;
	...
}
\end{lstlisting}}


Looking now at the \texttt{BlockStatement} interface\textcolor{red}{(Show it again)}, we see the three methods \texttt{execute}, \texttt{executeStart} and \texttt{stringRepr}. In some ways these are analogous to the methods found in the \texttt{Expression} interface. \texttt{stringRepr} returns a \texttt{String} representation of the statement, but also requires a \texttt{blocksDeep} parameter to know how many tab characters to put in front of the text. The \texttt{execute} method takes a \texttt{Context} object and a \texttt{depth} parameter and returns a \texttt{FlowControl} value. The \texttt{depth} parameter is used in scope management by the \texttt{removeDecsAtDepth} method in \texttt{StatementBase}. \texttt{FlowControl} is an enumeration determining what action must be taken after a statement is executed, and can take one of four values: \texttt{BREAK}, \texttt{CONTINUE}, \texttt{RETURN} and \texttt{NONE}. \texttt{executeStart} is simply a helper method for starting an execution with the appropriate initial depth value.

Whenever something goes wrong during execution, for example there is a type error or a variable is used before it is initialised, a custom exception is thrown. Information about the mistake that was made can be extracted from the exception type and from the message passed with it.

\section{The Parser}

In this section I explain how a parser for MiniJava was implemented using the ANTLR parser generator \cite{ANTLR4}, and how a MiniJava program tree can be built using it.

\textcolor{red}{("I based the parser grammar on an existing one for Java". Also justify this)}
The GitHub user antlr that owns the antlr4 project containing ANTLR has another project called grammars-v4\footnote{https://github.com/antlr/grammars-v4} that contains lots of example grammars that can be used with ANTLR, including one for Java. I was able to modify this grammar file, in a similar way to how I modified the Java grammar when designing MiniJava, to make a parser generator for MiniJava, \textcolor{red}{(I didn't make a parser generator! A parser generator made my parser to which I added actions)} which can be found in Appendix \ref{App:Parser}. When you \textcolor{red}{(Not you)} use antlr4 on the grammar file, the tool generates a number of files including a \texttt{<GrammarName>BaseVisitor}. By extending this class, one can add actions to the parser. By overriding the appropriate methods in this class, I was able to implement a parser that, given valid MiniJava code, could build a MiniJava program tree. \textcolor{red}{(Talk more about how the parser works)}

\section{The Abstract Question}
\textcolor{red}{(Make title more descriptive, and fix the capitals)}

In this section I explain the formulation of the abstract question and give an example of how a concrete question can be derived from it. \textcolor{red}{(Explain this)}

\textcolor{red}{("The Implementation chapter should not just be a description of every class in your implementation, but an explanation of the key problems you had to solve and how you solved them. From reading your Implementation so far, I have no good idea for why any of these components exist, how they fit together, and what problems they solve.")}

The abstract class \texttt{AbstractPExercise} represents an abstract programming exercise. It has fields including \texttt{question} (a \texttt{String} containing the question shown to students), \texttt{solution} (a \texttt{BlockStatement} object containing the model solution for the problem) and \texttt{baseDifficulty} (a measurement of the relative difficulty of this exercise compared to others, imposes a natural ordering on exercises in terms of their difficulty), and abstract methods including \texttt{setUp} (where the model solution is built) and \texttt{checkSolved} (where the current response is run and the system can determine whether the student has solved the problem). The other fields are required for either actually running the answer, or for adding blanks to and removing blanks from the model solution.

An example implementation of these abstract methods is found in \texttt{FactorialExercise}, \textcolor{red}{(The code won't be provided so if referenced quote it)} an exercise in which the student is asked to use a while loop to calculate the factorial of some integer \texttt{n}, which is supplied on construction of the object. The overridden \texttt{setUp} method constructs the model solution \textcolor{red}{(Explain)}, which represents the code:

\begin{lstlisting}
int total = 1, n = N;
while (n > 1) {
	total *= n--;
}
\end{lstlisting}

where \texttt{N} is the number supplied at construction. This code calculates \texttt{N!} and stores it in \texttt{total} as required. The \texttt{solution} field from \texttt{AbstractPExercise} is filled with the \texttt{Block} object that contains the code. Note also that \texttt{FactorialExercise} defines a new \texttt{totalId} field of type \texttt{Id}, which represents the variable \texttt{total}. This is used in the overriden \texttt{checkSolved} method, where the value of \texttt{total} is checked against the correct answer of \texttt{N!}.

This demonstrates one of the two ways that solutions can be checked: either the value of a variable can be checked by storing its \texttt{Id} in a field and accessing its value later, or an output stream could be printed to using the standard \texttt{System.out.println} method that has been included in MiniJava for convenience and later checked.

In this section I have presented the class \texttt{AbstractPExercise} and given an example implementation of it.

\section{Adding and Removing Blanks}
\label{Sec:Blanks}

This section explains the implementation of \texttt{FillableBlank} and its two implementations, before describing the algorithm that adds a blank to a MiniJava program that can later be filled in by a student, and the algorithm that replaces a blank with the original code snippet.

\texttt{FillableBlank} is an abstract class that encapsulates the behaviour of having a unique id and storing the number of nodes that this blank replaces. It is inherited by both \texttt{FillableBlankExpr} and \texttt{FillableBlankStmnt}. \texttt{FillableBlankExpr} implements \texttt{Expression} and \texttt{FillableBlankStmnt} implements \texttt{BlockStatement}, such that both are also \texttt{MiniJASTNodes}. Each stores a \texttt{MiniJASTNode} of the appropriate classification that is either \texttt{null}, or represents student code. 

The algorithm that adds a blank to a MiniJava program is found in the \texttt{addBlank} method of the \texttt{AbstractPExercise} class. The precondition for the algorithm is that the \texttt{solution} field contains a MiniJava program with a certain percentage blank. The postcondition is that either the solution was entirely blank, in which case the algorithm returns false, or the \texttt{solution} field contains the same MiniJava program but with a larger percentage blank, the head of the \texttt{replacedNodes} stack is the replaced node, and the head of the \texttt{replacedNodeTreeIndices} stack is a stack containing the indices describing the path to the blank that has just been added. The increase in percentage blank will be the smallest increment possible at that time.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{Searches}
\caption{A figure demonstrating the different behaviour of a depth first search algorithm and my \texttt{addBlank} algorithm.}
\label{Fig:Searches}
\end{figure}
\textcolor{red}{(Reverse Breadth First Search maybe?)}

In order to ensure the increase in percentage blank is the smallest increment possible, the algorithm always selects a leaf to replace with a blank, where here a leaf is defined as a node that either has no children, or all its children are already blank. This desire to reach leaves quickly motivates the use of a depth first search algorithm, but using it without modification presents a problem. Figure \ref{Fig:Searches} shows the difference between the selection made by a depth first search algorithm and the selection that should be made. In the diagram, the black nodes represent blanks, and the white nodes represent nodes in the tree that we might choose to make blank. We see that a normal depth first search algorithm would select node A next, whereas \texttt{addBlank} should select node B. As such, we introduce the notion of ``marking'' a node. When we detect that all of node A's children are blank, we declare that that node is a leaf and we mark it. At this point, the algorithm is looking to replace only unmarked leaves, so on this pass node B will be selected, and on the next pass node A will once again not be selected. Only when all the leaves at this depth have been made blank will node A be made blank.

The nodes are stored in a stack as they are dealt with. However, because more information is required as the algorithm progresses, the parent of the current node being considered, the index of the current node within its parent's \texttt{subnodes} field, and whether the current parent has all its children blank are also stored in stacks. We start by adding the root node of the solution tree to the nodes stack. When we reach a node, it falls in to one of four categories:
\begin{description}
\item[This node's children have already been searched:] {In this case, we need to check whether all of this node's children are blank. If they are, then technically this node is a leaf, but we don't want to replace it next walk of the tree so we mark it accordingly. Either way, we move on to the next node.}
\item[This node is a leaf:]{If this node is marked appropriately, then we need to go about replacing it with a blank. First we will check if this node is in fact the root node, in which case we can replace the entire solution with a blank. Either way, we store the replaced node itself and the path through the tree to its location in terms of indices so that it can later be reinserted if necessary. If the node to be replaced is an \texttt{Expression}, we replace it with a blank expression, otherwise we replace it with a blank statement. Either way we return true, as a replacement has been made.

If instead the node is not marked appropriately, then we move on to the next node after recording that the current parent has a child that is not blank.}
\item[This node is blank:]{If this node is the root of the tree, then the entire solution is blank, and we can't add any more blanks, so we return false. Otherwise, we simply move on to the next node.}
\item[This node is none of the above, and thus has children that need searching:]{In this case we need to register that we are increasing our depth of search. This means we add the current node to the parents stack, we add a new 0 to the indices stack and we add a true to the \texttt{childrenBlank} stack after first recording that the old parent has a child that isn't blank. We then add all this node's children to the nodes stack in reverse order, so that they emerge from the stack in the correct order.}
\end{description}

Within the \texttt{while(true)} loop the entire solution tree is walked. \textcolor{red}{Remove reference to code that can't be seen!)}If a result has not been reached in one iteration of the loop, then all the leaves are marked for not being selected this walk of the tree, so we change the marking we are looking for and walk the solution tree again.

The algorithm that removes a blank from a MiniJava program is found in the \texttt{removeBlank} method of the \texttt{AbstractPExercise} class. It is somewhat simpler than the \texttt{addBlank} method discussed before, as it simply makes use of all the information that has to be recorded during the execution of \texttt{addBlank}. If the \texttt{replacedNodes} stack is empty then there are no blanks to be removed, so we return false. If instead the head of the \texttt{replacedNodeTreeIndices} stack is empty, then we are replacing the whole solution with the head of the \texttt{replacedNodes stack}. Otherwise, we need to follow the path described in the head of the \texttt{replacedNodeTreeIndices} stack (once it has been reversed, since it was stored reversed during \texttt{addBlank}), to find the location of the blank that needs to be replaced by the head of the \texttt{replacedNodes}. We need to make sure that the parent of this node is no longer considered a leaf, and we also need to make sure that if the marking we are searching for was just changed by the last \texttt{addBlank} invocation (i.e. the index we have is always the largest possible) then we change it back now.

This section first explained how the notion of a fillable blank was added to MiniJava, before describing the implementations of the algorithms that introduce them to and remove them from a MiniJava program.

\section{The \texttt{ExerciseSetter}}

In this section I describe how I made use of the language and its features to design the \texttt{ExerciseSetter}, one possible way in which students might interface with exercises designed to facilitate the learning of MiniJava.

The \texttt{ExerciseSetter} stores a list of possible exercises in order of increasing difficulty. The initial exercise to be delivered can be easily adjusted by changing the field \texttt{INITIAL\char`_EX}, and the current exercise index is also stored, along with a reference to that exercise. To measure the difficulty of the exercise and the performance of the students, the number of attempts at a solution made, the number of nodes in the solution, and the number of blanks added are also stored. A lot of the code in this class goes toward keeping these values consistent. The \texttt{ExerciseSetter} also stores a reference to an \texttt{OutputStream}, where all the output can be written to. This allows the \texttt{ExerciseSetter} to be plugged in to other peripherals, like the GUI described below. Finally, it also stores a reference to the parser.

A lot of the methods in this class are helper methods, simply passing messages between the exercise and the student. The important ones are \texttt{fillBlank}, \texttt{reportPerformance}, and \texttt{adjustQuestion}.

\texttt{fillBlank} has two method signatures, one that takes a \texttt{MiniJASTNode}, and one that takes a \texttt{String}. The one that takes a \texttt{MiniJASTNode} is trivial and thus unimportant, but the one that takes a \texttt{String} is more interesting. This method makes use of the parser in an interesting way, as there is of course some ambiguity in the language. The specific ambiguity comes from certain code snippets having the potential to be both \texttt{Expression}s and \texttt{BlockStatement}s. An example of this is the code snippet \texttt{total = 1}. This can be parsed as an assignment, and would thus be classed an \texttt{Expression}, or a variable declaration, where the surrounding context might be \texttt{int total = 1;}, which would categorise this snippet as a \texttt{BlockStatement}. To make the decision, the \texttt{ExerciseSetter} first checks if the blank being filled represents an \texttt{Expression} or a \texttt{BlockStatement}, and sets the entry point for the parser appropriately.

\texttt{reportPerformance} is a possible implementation of a performance heuristic. Performance is based on the number of attempts the exercise took to solve, and the number of nodes in the solution compared with the model solution. The more attempts required and the more nodes in the solution, the worse the performance. A negative result here indicates that the next exercise should be easier, while a positive result indicates it should be harder.

\texttt{adjustQuestion} is a possible implementation of how the performance might influence the difficulty of the next problem. If the next exercise needs to be harder, then the \texttt{ExerciseSetter} adds blanks to the solution until either the exercise is hard enough, or the entire solution is blank. If the latter occurs, then the \texttt{ExerciseSetter} attempts to present a harder problem, and calculate how much of it should be blank. If instead the exercise needs to be easier, then the \texttt{ExerciseSetter} removes blanks from the solution until either the exercise is easy enough, or there are no blanks in the solution. If the latter occurs, then the \texttt{ExerciseSetter} attempts to present an easier problem and calculates how much of it should be blank.

In this section I have detailed one of the ways that students might interface with MiniJava through the \texttt{ExerciseSetter}. This is only an example of a possible use for the tools, but shows how powerful they can be.

\section{The GUI}

In this section I describe the implementation and function of the GUI peripheral.

\begin{figure}[h]
\centering
\includegraphics[width = \textwidth]{GUI}
\caption{An example screenshot taken of the GUI peripheral.}
\label{Fig:GUI}
\end{figure}

The GUI demonstrates some of the possible uses of this set of tools. It shows how a teacher might manually set the difficulty of a particular exercise and how a student could fill in the blanks and run their solution. An example screen from the GUI is shown in Fig 3. The top slider determines the problem that is presented: the further to the left the slider is, the easier the problem will be. The bottom slider affects the difficulty of that problem: the further it is to the left, the fewer blanks there will be and thus the easier the problem will be to solve. When the ``Generate'' button is pressed, the corresponding exercise will be displayed in the box on the right. 

When an exercise is generated, the blanks within the solution that need to be filled are shown as numbers in brackets surrounded by ellipses. To fill one of the blanks, the user must enter its number in the spinbox, and then enter the code with which to fill the blank in the text box, before pressing the button marked ``Fill Blank''. A blank with a given number can be emptied by entering its number into the spinbox and pressing the button marked ``Empty Blank''. The solution, i.e. the text in the large box on the right, can be executed at any time by pressing the ``Run'' button. The GUI will report whether the solution is correct or not.

The GUI was designed using the IntelliJ UI Designer plugin\footnote{https://www.jetbrains.com/help/idea/2017.1/swing-designing-gui.html}. This plugin allowed me to drag and drop components into place on the form before programming their functionality with the adjoining bound class. The class stores a reference to an \texttt{ExerciseSetter} object, which is where all the data comes from, and where the commands from the user are delivered to. It also makes use of the \texttt{ExerciseSetter}'s \texttt{setOutput} method by giving it a \texttt{ByteArrayOutputStream} that can then be read as text to be displayed. There is some error handling involved in that when something goes wrong, e.g. the user attempts to fill a blank with a number that isn't in the solution, or a solution run raises an error, the error is propagated up from the \texttt{ExerciseSetter} and displayed in the GUI.

This section described the function and then the implementation of the GUI peripheral.\\

In this chapter I have described what I have implemented and how I have done it. I started by giving the design of the language MiniJava, explaining some of these choices by introducing the parser and the concept of ``blanks'' within a MiniJava program. From there I explained how a programming exercise is conceptualised in the abstract sense, and gave an example of an implementation of a specific question. I finished by giving two possible uses for the set of tools, the \texttt{ExerciseSetter} and the Graphical User Interface (GUI).

\textcolor{red}{Estimated Word Count: 3765}

\chapter{Evaluation}

\chapter{Conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{refs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{The Parser}
\label{App:Parser}

\begin{lstlisting}
grammar MiniJava;

// STATEMENTS / BLOCKS

// entry point
entry
	: block [true]			# blockEntry
	| blockStatement+		# blockStatementsEntry
	| statementTop			# statementEntry
	| expression			# expressionEntry
	;									

block [boolean isOuter]
    :   LBRACE blockStatement* RBRACE						
    ;

blockStatement
    :   primitiveType variableDeclarators SEMI	# localVariableDeclaration
    |   statement								# makeStmnt
    | 	variableDeclarator						# makeVarDec
    ;
    
statementTop
	:	statement						# stmnt
	|	statementNSI					# stmntNSI
	;

statement
    :	block [false]									# makeBlock
    |   IF parExpression statement 						# makeIf
    | 	IF parExpression statementNSI ELSE statement	# makeITE
    |   FOR LPAREN forInit? SEMI expression? 
    			SEMI expressionList? RPAREN  statement	# makeFor
    |   WHILE parExpression statement					# makeWhile
    |   statementNTS									# makeStatementNTS
    ;
    
statementNSI
	:  block [false]										# makeBlockNSI
	| IF parExpression statementNSI ELSE statementNSI		# makeITENSI
	| FOR LPAREN forInit? SEMI expression? 
			SEMI expressionList? RPAREN statementNSI 		# makeForNSI
    |   WHILE parExpression statementNSI					# makeWhileNSI
    |	statementNTS										# makeStatementNTSNSI												
    ;
    
statementNTS
	:	DO statement WHILE parExpression SEMI	# makeDo
    |   RETURN SEMI								# return
    |   BREAK SEMI								# break
    |   CONTINUE SEMI							# continue
    |   SEMI									# empty
    |   expressionStatement SEMI				# makeStmntExpr
    ;


forInit
    :   primitiveType variableDeclarators			# forInitLVD
    |   expressionList								# forInitExprs
    ;

// EXPRESSIONS

parExpression
    :   LPAREN expression RPAREN
    ;

expressionList
    :   expression (COMMA expression)*
    ;

expressionStatement
    :   expression
    ;

expression // Most binding comes first!
    :   Identifier												# makeID
    |   expression LBRACK expression RBRACK						# arrayAccess
    |	parExpression											# makeBracketed
    |   literal													# makeLiteral
    |   expression (op=INC | op=DEC)							# postInc
    |   (op=ADD|op=SUB|op=INC|op=DEC) expression				# preIncEtc
    |   BANG expression											# makeNot
    |   expression (op=MUL|op=DIV) expression					# multExpr
    |   expression (op=ADD|op=SUB) expression					# addExpr
    |   expression (op=LE | op=GE | op=GT | op=LT) expression	# relationalExpr
    |   expression (op=EQUAL | op=NOTEQUAL) expression			# eqExpr
    |   expression AND expression								# andExpr
    |   expression OR expression								# orExpr
    |   <assoc=right> expression QUESTION 
    		expression COLON expression							# condExpr
    |	<assoc=right> expression												
        (   op=ASSIGN
        |   op=ADD_ASSIGN
        |   op=SUB_ASSIGN
        |   op=MUL_ASSIGN
        |   op=DIV_ASSIGN
        )
        expression												# assignExpr
    ;
    
// VARIABLES AND LITERALS
    
variableDeclarators
    :   variableDeclarator (COMMA variableDeclarator)*
    ;

variableDeclarator
    :   Identifier LBRACK RBRACK (ASSIGN variableInitializer)? 	# arrayVarDec 
    |	Identifier (ASSIGN variableInitializer)?				# singleVarDec
    ;

variableInitializer 
    :   arrayInitializerValues									# arrayInitVals
    |	arrayInitializerSize									# arrayInitSize
    |   expression												# initExpr
    ;

arrayInitializerValues
    :   LBRACE variableInitializer (COMMA variableInitializer)* (COMMA)? RBRACE	
    ;
    
arrayInitializerSize
	: 	NEW primitiveType LBRACK expression RBRACK
	;

primitiveType
    :   BOOLEAN
    |   CHAR
    |   INT
    |   DOUBLE
    ;

literal
    :   IntegerLiteral 
    |   FloatingPointLiteral 
    |   CharacterLiteral
    |   BooleanLiteral
    ;

// LEXER

// §3.9 Keywords

BOOLEAN       : 'boolean';
BREAK         : 'break';
CHAR          : 'char';
CONTINUE      : 'continue';
DO            : 'do';
DOUBLE        : 'double';
ELSE          : 'else';
FOR           : 'for';
IF            : 'if';
INT           : 'int';
NEW			  : 'new';
RETURN        : 'return';
WHILE         : 'while';

// §3.10.1 Integer Literals
// §3.10.2 Floating-Point Literals
// §3.10.3 Boolean Literals
// §3.10.4 Character Literals
// §3.11 Separators
// Sections removed for clarity

LPAREN          : '(';
RPAREN          : ')';
LBRACE          : '{';
RBRACE          : '}';
LBRACK          : '[';
RBRACK          : ']';
SEMI            : ';';
COMMA           : ',';
DOT             : '.';

// §3.12 Operators

ASSIGN          : '=';
GT              : '>';
LT              : '<';
BANG            : '!';
QUESTION        : '?';
COLON           : ':';
EQUAL           : '==';
LE              : '<=';
GE              : '>=';
NOTEQUAL        : '!=';
AND             : '&&';
OR              : '||';
INC             : '++';
DEC             : '--';
ADD             : '+';
SUB             : '-';
MUL             : '*';
DIV             : '/';

ADD_ASSIGN      : '+=';
SUB_ASSIGN      : '-=';
MUL_ASSIGN      : '*=';
DIV_ASSIGN      : '/=';

// §3.8 Identifiers (must appear after all keywords in the grammar)
//
// Whitespace and comments
//
// Sections removed for clarity
\end{lstlisting}

\chapter{Project Proposal}

\input{proposal}

\end{document}
